<?php

/**
 * @file
 * This module collects RSS feeds from various parts of your site
 * Current supported RSS feeds: 
 * Views RSS, Blog RSS, Taxonomy RSS, Custom RSS, Atom feeds, and Aggregation OPML 
 *
 */

/**
 * Implementation of hook_menu().
 */
function syndication_menu() {
  $items['syndication'] = array(
    'title' => 'RSS feeds',
    'access arguments' => array('access content'),
    'page callback' => 'syndication_page',
    'weight' => 6
  );
  $items['admin/config/syndication'] = array(
    'title' => 'RSS feed syndication',
    'access arguments' => array('access administration pages'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('syndication_admin_settings'),
  );
  $items['syndication/builder'] = array(
    'title' => 'RSS feed builder',
    'access arguments' => array('access content'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('syndication_taxonomy_builder'),
  );
  $items['syndication/all'] = array(
    'title' => 'All feeds',
    'access arguments' => array('access content'),
    'page callback' => 'syndication_taxonomy_all_feeds',
    'type' => MENU_CALLBACK
  );
  return $items;
}

/**
 * Implementation of hook_block_info().
 */
function syndication_block_info() {
  $blocks[0] = array(
    'info' => t('Syndicate (more)')
  );
  
  return $blocks;
}

/**
 * Implementation of hook_block_view().
 *
 * Generates the syndication block for display.
 */
function syndication_block_view($delta = 0, $edit = array()) {
  if (user_access('access content')) {
    $block['subject'] = t('Syndicate');
    $pagetype = arg(0);
    if ($pagetype == 'blog') {
      $userid = arg(1);
      $linkurl = is_numeric($userid) ? "blog/$userid/feed" : 'blog/feed';
    }
    else {
      $linkurl = 'rss.xml';
    }
    
    $feed_icon = array('url' => url($linkurl),
                       'title' => t('More')
                      );
    
    $block['content'] = theme('feed_icon', $feed_icon);
    $block['content'] .= '<div class="more-link">' . l(t('more'), 'syndication', array('title' => t("Review all XML feeds exported by %sn", array("%sn" => variable_get('site_name', 'Drupal'))))) . "</div>\n";
    return $block;
  }
}

/**
 * Menu callback
 * Syndication page.
 */
function syndication_page() {
  drupal_add_css(drupal_get_path('module', 'syndication') . '/syndication.css');
  
  //atom
  if (module_exists('atom') && variable_get('syndication_atom', 0)) {
    $box = array('title' => t('Atom feed'),
                 'content' => l(t('Atom front page feed'), 'atom/feed')
                );
                
    $build[] = array(
      '#prefix' => '<div class="syndication_feed_type">1',
      '#markup' => theme('syndication_box', $box),
      '#suffix' => '</div>',
    );
  }
  
  //blogs
  if (module_exists('blog') && variable_get('syndication_blogs', 0)) {
    $box = array('title' => t('Blogs'),
                 'content' => syndication_blogs()
                );
                
    $build[] = array(
      '#prefix' => '<div class="syndication_feed_type">2',
      '#markup' => theme('syndication_box', $box),
      '#suffix' => '</div>',
    );
  }
  
  //aggregator
  if (module_exists('aggregator') && user_access('access news feeds') && variable_get('syndication_aggregator', 0)) {
    $box = array('title' => t('External feeds'),
                 'content' => syndication_opml()
                );
                
    $build[] = array(
      '#prefix' => '<div class="syndication_feed_type">3',
      '#markup' => theme('syndication_box', $box),
      '#suffix' => '</div>',
    );
  }
  
  //taxonomy
  if (module_exists('taxonomy') && user_access('access content')) {
    $syndication_vocab =  variable_get('syndication_vocabularies', array());
    foreach ($syndication_vocab as $key => $value) {
      // Throw away the vids that aren't enabled.
      if (!$value) {
        unset($syndication_vocab[$key]);
      }
    }

    $box = array('title' => t('Categories'),
                 'content' => syndication_vocabularies()
                );
    
    $build[] = array(
      '#prefix' => '<div class="syndication_feed_type">4',
      '#markup' => theme('syndication_box', $box),
      '#suffix' => '</div>',
    );
  }
  
  //views
  $syndication_views = variable_get('syndication_views', array());
  if (module_exists('views') && !empty($syndication_views)) {
    if ($views = syndication_views_rss()) {
      $box = array('title' => t('Views'),
                   'content' => $views
                  );
                  
      $build[] = array(
        '#prefix' => '<div class="syndication_feed_type">5',
        '#markup' => theme('syndication_box', $box),
        '#suffix' => '</div>',
      );
    }
  }
  
  //custom
  $syndication_custom = variable_get('syndication_custom', array());
  if (!empty($syndication_custom)) {
    foreach ($syndication_custom as $name) {
      $result = module_invoke($name, 'syndication');
      foreach ($result as $b) {
        $box = array('title' => $b['subject'],
                     'content' => $b['content']
                    );
        
        $build[] = array(
          '#prefix' => '<div class="syndication_feed_type">',
          '#markup' => theme('syndication_box', $box),
          '#suffix' => '</div>',
        );
      }
    }
  }
  if (empty($build)) {
      $build[] = array(
        '#prefix' => '<div class="syndication_message">',
        '#markup' => t('Sorry, there are no feeds available.'),
        '#suffix' => '</div>',
      );
  }

  return $build;
}

/**
 * Generate a form for searching for user blogs feeds.
 * @return $form fragment
 */
function syndication_users() {
  if (module_exists('atom')) {
    $prefix = '<p>' . t("At <i>%sn</i>, all users have a <a href='!rss'>RSS</a> and <a href='!atom'>Atom<a> feed for their blog, as well as each individual user.",
      array('%sn' => variable_get('site_name', 'Drupal'), '!rss' => url('blog/feed'), '!atom' => url('blog/atom/feed'))) . '</p>';
  }
  else {
    $prefix = '<p>' . t("At <i>%sn</i>, <a href='!all'>all users</a> and each user, have an RSS feed for their blog.",
      array('%sn' => variable_get('site_name', 'Drupal'), '!all' => url('blog/feed'))) . '</p>';
  }
  $form['name'] = array(
    '#type' => 'textfield',
    '#title' => t('Search users'),
    '#prefix' => $prefix,
    '#description' => t('Enter a username to view her blog feed, and other details.'),
    '#autocomplete_path' => 'user/autocomplete',
  );
  $form['submit'] = array('#type' => 'button', '#value' => t('Search'));

  return $form;
}

/**
 * Implementation of hook_validate().
 * Validates user blog feed search form.
 */
function syndication_users_validate($form, &$form_state) {
  $result = db_query("SELECT uid, name FROM {users} WHERE name LIKE %:name% AND uid > 0 ORDER BY access DESC", array(':name' => $form_state['values']['name']));
  if (!empty($result)) {
    $form_state['values']['result'] = $result;
  }
  else {
    form_set_error('name', t('Username not found.'));
    drupal_goto('syndication');
  }
}

/**
 * Generate a list of feeds for personal blogs.
 */
function syndication_blogs() {
  $result = db_query_range("SELECT DISTINCT(u.uid), u.name FROM {users} u INNER JOIN {node} n ON u.uid = n.uid WHERE n.type = :type'blog' AND n.status = :status", 0, 16, array(':type' => 'blog', ':status' => 1));
  foreach($result as $account) {
    $author = $account->name . ': ' . l(t('RSS feed'), "blog/$account->uid/feed");
    $author .= module_exists('atom') ? ', ' . l(t('Atom feed'), "blog/$account->uid/atom/feed") : '';
    $authors[] = $author;
  }
  if ($authors) {
    $item_list = array('items' => $authors,
                       'title' => t('Recent Blog Authors'),
                       'type' => 'ul'
                      );
                      
    $output = theme('item_list', $item_list);
  }

  $output .= drupal_get_form('syndication_users');

  if ($name = $_POST['name']) {
    $result = db_query("SELECT uid, name FROM {users} WHERE uid > 0 and name LIKE %:name% ORDER BY access DESC", array(':name' => $name));
    $i=0;
    foreach ($result as $account) {
       $rows[$i][] = theme('username', array('account' => $account)) . ':';
       $rows[$i][] = l(t("RSS feed"), "blog/$account->uid/feed");
      if (module_exists('atom')) {
        $rows[$i][] = l(t("Atom feed"), "blog/$account->uid/atom/feed");
      }
      $rows[$i][] = l(t("blog"), "blog/$account->uid");
      $i++;
    }
    if ($rows) {
      $table = array('header' => NULL,
                     'rows' => $rows
                    );
      
      $output .= theme('table', $table);
    }
  }

  return $output;
}

/**
 * Produce a list of terms for each enabled vocabulary
 * @return HTML
 */
function syndication_vocabularies() {
  $syndication_columns = variable_get('syndication_columns', 3);
  $vocab_number = 0;
  $has_items = FALSE;
  
  $columns = array();
  $columns = array_pad($columns, $syndication_columns, ''); //check this
  foreach (variable_get('syndication_vocabularies', array()) as $vid) {
    $vocab = taxonomy_vocabulary_load($vid);
    $tree = taxonomy_get_tree($vid);
    if ($tree) {
      $items = syndication_taxonomy_build_list_items($index = 0, $tree);
      if ($items) {
        $col_num = $vocab_number % $syndication_columns;
        $item_list = array('items' => $items,
                           'title' => t($vocab->name),
                           'type' => 'ul'
                          );
        
        $columns[$col_num] .= theme('item_list', $item_list);
        $vocab_number++;
        $has_items = TRUE;
      }
    }
  }
  
  $output = '';
  if ($has_items) {
  print_r($columns);
    $output .= theme('syndication_columns', array('data' => $columns));
    $output .= l(t('Combine terms into a single feed'), 'syndication/builder');
  }
  
  return $output;
}

/**
 * Helper function for syndication_taxonomy.
 */
function syndication_taxonomy_build_list_items(&$index, $tree) {
  $show_unused_terms = variable_get('syndication_vocabularies_empty', 0);
  $items = array();
  $current_depth = $tree[$index]->depth;
  while ($index < count($tree) && $tree[$index]->depth >= $current_depth) {
    $term = $tree[$index];
    $count = syndication_taxonomy_term_count_nodes($term->tid);
    if ($count || $show_unused_terms) {
      $child_tids = array_keys(taxonomy_get_children($term->tid));
      if (count($child_tids) > 0) {
        $tid_list = $term->tid . '+' . implode('+', $child_tids);
        $term_path = "taxonomy/term/$tid_list/0/feed";
      }
      else {
        $term_path = "taxonomy/term/{$term->tid}/0/feed";
      }
      $term_link = l(t($term->name), $term_path, array('title' => $term->description));
      if ($term->depth) {
        $prefix = str_repeat('--', $term->depth) . ' ';
      }
      else {
        $prefix = "";
      }
      $item = $prefix . $term_link . " ($count)";
      $items[] = $item;
      $index++;
    }
    else {
      $index++;
    }
  }
  return $items;
}

/**
 * Menu callback for syndication_taxonomy_builder.
 */
function syndication_taxonomy_builder() {
  $show_unused_terms = variable_get('syndication_vocabularies_empty', 0);
  
  $form['intro'] = array(
    '#type' => 'markup',
    '#value' => t('You can subscribe to more than one category in a single RSS feed.  Please select the RSS feeds you would like to subscribe to then press the "Generate feed" button.'),
  );
  $form['all_feeds'] = array(
    '#type' => 'markup',
    '#value' => ' ' . l(t('You may also subscribe all terms on this site.'), 'syndication/all'),
  );
  
  foreach (variable_get('syndication_vocabularies', array()) as $vid) {
    $vocab = taxonomy_vocabulary_load($vid);
    $tree = taxonomy_get_tree($vid);
    $items = syndication_taxonomy_build_list_items($index = 0, $tree);
    if ($items) {
      $index = 0;
      $options = array();
      $current_depth = $tree[$index]->depth;
      $form['categories'][$vocab->name] = array(
        '#type' => 'fieldset',
        '#title' => t($vocab->name),
        '#collapsible' => TRUE,
        '#collapsed' => FALSE,
      );
      while ($index < count($tree) && $tree[$index]->depth >= $current_depth) {
        $term = $tree[$index];
        $count = syndication_taxonomy_term_count_nodes($term->tid);
        if ($count || $show_unused_terms) {
          $offset = '';
          for ($i = 0; $i < $tree[$index]->depth*2; $i++) {
            $offset .= '-';
          }
          $term_name = $tree[$index]->depth == 0 ? '<strong>' . t($term->name) . '</strong>' : t($term->name); 
          $options[$term->tid] = $offset . $term_name;
          $index++;
        }
        else {
          $index++;
        }
      }
      //the vocab name must be urlencoded here because this breaks if there is a space in the vocab name
      $form['categories'][$vocab->name][urlencode($vocab->name)] = array(
        '#type' => 'checkboxes',
        '#options' => $options,
        '#columns' => variable_get('syndication_columns', 3),
        '#theme' => 'syndication_taxonomy_builder_columns_checkboxes',
      );
    }
  }
  
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Generate feed'),
  );
  return $form;
}

/**
 * Implementation of hook_submit
 */
function syndication_taxonomy_builder_submit($form, &$form_state) {
  foreach ($form_state['values'] as $category) {
    if (is_array($category) && !empty($category)) {
      foreach ($category as $vid => $enabled) {
        if ($enabled >0) {
          $feed[] = $vid;
        }
      }
    }
  }
  if (!empty($feed)) {
    drupal_goto("taxonomy/term/" . implode("+", $feed) . "/0/feed");
  }
}

/**
 * Build a fresh feed containing all enabled terms
 */
function syndication_taxonomy_all_feeds() {
  foreach (variable_get('syndication_vocabularies', array()) as $vid) {
    $tree = taxonomy_get_tree($vid);
    $index = 0;
    $options = array();
    $current_depth = $tree[$index]->depth;
    while ($index < count($tree) && $tree[$index]->depth >= $current_depth) {
      $term = $tree[$index];
      $feed[] = $term->tid;
      $index++;
    }
  }
  drupal_goto("taxonomy/term/" . implode("+", $feed) . "/0/feed");
}

/**
 * Generates a link to aggregator.module OPML file.
 */
function syndication_opml() {
  $output = t('In addition to displaying RSS feeds, <i>%sn</i> offers <a href="!link">this OPML</a> which lists all RSS feeds that are collected here.',
              array('%sn' => variable_get('site_name', 'Drupal'), '!link' => url('aggregator/opml')));
  return $output;
}

/**
 * Generates a list of feeds from views_rss.module.
 */
function syndication_views_rss() {
  $vids = variable_get('syndication_views', array());
  foreach ($vids as $key => $value) {
    // Throw away the vids that aren't enabled.
    if (!$value) {
      unset($vids[$key]);
    }
  }
  // Only bother getting results if at least one vid is enabled.
  if ($vids) {
    $result = _syndication_return_views_rss_feeds($vids);
    foreach ($result as $view_item) {
      $access_type = 'none';
      $access_info = '';
      $display = $view_item->display[$view_item->display_of_interest];
      $feed_path = $display->display_options['path'];
      $feed_title = $display->display_title;
      /*
      Access control appears to only be applicable to the default display
      if ($display->access['type'] == 'perm' || $display->access['type'] == 'role') {
        //access applied to this display
        $access_type = $display->access['type'];
        $access_info = $display->access[$access_type];
      }
      else
      */
      if ($view_item->display['default']->display_options['access']['type'] == 'perm' || $view_item->display['default']->display_options['access']['type'] == 'role') {
        //access plugin applied to default display
        $access_type = $view_item->display['default']->display_options['access']['type'];
        $access_info = $view_item->display['default']->display_options['access'][$access_type];
      }
      $access_callbacks = array('role' => 'views_check_roles', 'perm' => 'user_access');
      if (user_access('access all views') || $access_type == 'none' || (function_exists($access_callbacks[$access_type]) && call_user_func($access_callbacks[$access_type], $access_info))) {
        $items[] = l($feed_title, $feed_path, array('attributes' => array('class' => 'syndication_view_rss')));
      }
    }
    $item_list = array('items' => $items,
                       'title' => NULL,
                       'type' => 'ul'
                      );
    $output = theme('item_list', $item_list);
  }
  return $output;
}

/**
 * Helper function to get all views that generate rss feeds from the database.
 * Accepts an array of views ids (vids) to limit the results.
 *
 * @param $args
 *   An array of views ids.
 * @return
 *   Database result object ( containing the vid, name, and display_title) or null if no feeds exist.
 */
function _syndication_return_views_rss_feeds($vids = array()) {
  if (!empty($vids)) {
    $result = db_query("SELECT vv.name, vd.id FROM {views_display} vd JOIN {views_view} vv ON vd.vid = vv.vid WHERE vd.display_plugin = :plugin AND vv.name IN (:vids)", array(':plugin' => 'feed', ':vids' => $vids));
  }
  else {
    $result = db_query("SELECT vv.name, vd.id FROM {views_display} vd JOIN {views_view} vv ON vd.vid = vv.vid WHERE vd.display_plugin = :plugin", array(':plugin' => 'feed'));
  }
  
  $view = array();
  foreach ($result as $row) {
    $item = views_get_view($row->name);
    $item->display_of_interest = $row->id;
    $view[] = $item;
  }
  return $view;
}

/**
 * Theme views_rss feeds list.
 * @param $variables
 * @return HTML
 */
function theme_syndication_views_rss($variables) {
  $rows = $variables['rows'];
  
  if (is_array($rows)) {
    $item_list = array('items' => $rows,
                       'title' => NULL,
                       'type' => 'ul'
                      );
    $output = theme('item_list', $item_list);
  }
  
  return $output;
}

/**
 * Syndication module configuration form.
 */
function syndication_admin_settings() {
  //general
  $form['syndication_columns'] = array(
    '#type' => 'textfield',
    '#title' => t('Columns'),
    '#default_value' => variable_get('syndication_columns', 3),
    '#description' => t('The number of columns to use on the display page?'),
  );

  //blogs
  if (module_exists('blog')) {
    $form['syndication_blogs'] = array(
      '#type' => 'checkbox',
      '#title' => t('Blogs'),
      '#default_value' => variable_get('syndication_blogs', 0),
      '#description' => t('Should be blogs be included on the syndication page?'),
    );
  }
  
  //atom front page feed
   if (module_exists('atom')) {
    $form['syndication_atom'] = array(
      '#type' => 'checkbox',
      '#title' => t('Atom feed'),
      '#default_value' => variable_get('syndication_atom', 0),
      '#description' => t('Should be front page atom feed be included on the syndication page?'),
    );
  }
  //aggregotor front page feed
   if (module_exists('aggregator'))  {
    $form['syndication_aggregator'] = array(
      '#type' => 'checkbox',
      '#title' => t('Atom feed'),
      '#default_value' => variable_get('syndication_aggregator', 0),
      '#description' => t('Should be aggregator OPML feed be included on the syndication page?'),
    );
  }

  //taxonomy
  if (module_exists('taxonomy'))  {
    foreach (taxonomy_get_vocabularies() as $vid => $vocab) {
      $options[$vid] = t($vocab->name);
    }
    $form['syndication_vocabularies'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Vocabularies'),
      '#options' => $options,
      '#default_value' => variable_get('syndication_vocabularies', array()),
      '#description' => t('Select the vocabularies which should appear in the <em>Categories</em> block on the <a href="@syndication">syndication page</a>', array('@syndication' => url('syndication'))),
    );
    $form['syndication_vocabularies_empty'] = array(
      '#type' => 'radios',
      '#title' => t('Taxonomy terms with no nodes'),
      '#options' => array(0 => t('Do not show terms which are not used by any nodes'), 1 => t('Show terms which are not used by any nodes')),
      '#default_value' => variable_get('syndication_vocabularies_empty', 0),
    );
  }
  
  //views
  if (module_exists('views')) {
    $options = array();
    $views = _syndication_return_views_rss_feeds();
    foreach ($views  as $view) {
      $options[$view->name] = t($view->display[$view->display_of_interest]->display_title);
    }
    $form['syndication_views'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Views'),
      '#options' => $options,
      '#default_value' => variable_get('syndication_views', array()),
      '#description' => t('Select the views which should appear in the <em>Views</em> block on the <a href="@syndication">syncidation page</a>', array('@syndication' => url('syndication'))),
    );
  }

  //hook_syndication implementations
  unset($options);
  foreach (module_list() as $name) {
    $result = module_invoke($name, 'syndication');
    if (isset($result)) {
      foreach ($result as $box) {
        $options[] = $box['subject'];
      }
    }
  }
  if (!empty($options)) {
    $form['syndication_custom'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Other'),
      '#options' => $options,
      '#default_value' => variable_get('syndication_custom', array()),
      '#description' => t('Select the other feeds which should appear in the <em>Other</em> block on the <a href="@syndication">syncidation page</a>', array('@syndication' => url('syndication'))),
    );
  }
  return system_settings_form($form);
}

/**
 * Implementation of hook_help().
 */
function syndication_help($path, $arg) {
  $output = '';
  switch ($path) {
    case 'admin/help#syndication':
      $output = syndication_help_intro();
      break;
    case 'admin/modules#description':
      $output .= t("Adds a Syndication block, links to more feeds");
      break;
  }
  return $output;
}

/**
 * Helper function for syndication_help().
 * @return Help text
 */
function syndication_help_intro() {
  $output = '
<p>Syndication.module offers a web page which centralizes all of the RSS feeds
generated by Drupal. This helps users find interesting feeds from your web site.</p>

<p>Currently, the syndication page helps visitors find the following feeds.
<ul>
<li>the blog feed of any user or all users
<li>node feeds for any taxonomy terms, including composites of terms (requires <i>taxonomy_dhtml.module</i>)
<li>a directory of all feeds being consumed by the <i>import.module</i>
</ul>
</p>

<h3>For Module Developers - Syndication hook</h3>
<p> See hook_syndication() which is provided by this module.
</p>';

  return $output;
}

/**
 * Count the number of nodes used by this taxonomy term
 * @param $tid
 *   The taxonomy term to count the nodes for
 * @return
 *   The number of nodes with this taxonomy term applied.
 */
function syndication_taxonomy_term_count_nodes($tid) {
  if (!variable_get('taxonomy_maintain_index_table', TRUE)) {
    return 0;
  }
  $query = db_select('taxonomy_index', 't');
  $query->addTag('node_access');
  $query->condition('tid', $tid);
  $query->addExpression('COUNT(t.nid)');

  $result = $query->execute()->fetchCol();
  return $result[0];
}

/**
 * Implementation of hook_theme().
 */
function syndication_theme() {
  return array(
    'syndication_box' => array(
      'variables' => array('element' => array()),
    ),
    'syndication_taxonomy_builder_columns_checkboxes' => array(
      'variables' => array('element' => array()),
    ),
    'syndication_columns' => array(
      'variables' => array('data' => array()),
    ),
    'syndication_views_rss' => array(
      'variables' => array(),
    ),
  );
}

/**
 * Themes content with a title
 * @param $variables
 * @return HTML
 */
function theme_syndication_box($variables) {
  $title = $variables['title'];
  $content = $variables['content'];
  
  $output = '<h2 class="title">' . $title . '</h2><div>' . $content . '</div>';
  
  return $output;
}

/**
 * Converts a list of taxonomy terms into checkboxes and displays them in columns
 * @param array $variables
 * @return HTML
 */
function theme_syndication_taxonomy_builder_columns_checkboxes($variables) {
  $element = $variables['element'];
  
  $options = $element['#options'];
  if (count($options) < $element['#columns']) {
    $element['#columns'] = 1; //if there are less terms than columns then put them in one column
  }
  $rows = array();
  foreach ($options as $key => $value) {
    $row[] = drupal_render($element[$key]);
    if (count($row) == $element['#columns']) {
      array_push($rows, $row);
      $row = array();
    }
  }
  // This flushes out the columns when the items don't divide evenly into the columns.
  if (count($row)) {
    array_push($rows, $row);
  }
  
  $table = array('header' => NULL,
                 'rows' => $rows
                );
  
  return theme('table', $table);
}

/**
 * Display data into columns
 * @param array $variables
 * @return HTML
 */ 
function theme_syndication_columns($variables) {
  $data = $variables['data'];
  
  $output = '';
  $cols = count($data);
  $width = (int)((100/$cols) - 1); // make this a fraction smaller so the percentages won't add up to more than 100%
  foreach ($data as $col) {
    $output .= "<div class='syndication-column' style='width:$width%'>";
    $output .= $col;
    $output .= "</div>";
  }
  $output .= '<div class="syndication-clear"></div>';
  
  return $output;
}
